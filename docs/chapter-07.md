
## 7. 기본 실천방법

### 7.1. 함께 앉기

개발 작업은 팀 전체가 들어가기 충분한 크기로 열린 공간에서 한다. 
사생활 욕구나 나만의 공간 욕구는 가까운 곳에 작은 사적 공간들을 만들어서 해결한다. 
문제는 항상 사람이다. 
기술적인 해결책만으로 충분하지 않다. 
함께 앉아 우리의 모든 감각을 이용하여 의사소통하는 것이 중요하다. 

팀이 준비되기 전에 파티션을 허물면 생산성이 오히려 낮아진다. 
팀의 속도에 맞게 천천히 진전시킨다. 

함께 앉기를 통해 얼굴을 맞대는 시간이 길면 프로젝트가 더 인간적이 되고 생산적이 되리라 예측한다. 

### 7.2. 전체 팀

프로젝트가 성공하기 위해 필요한 기술과 시야를 지닌 사람들을 전부 팀에 포함시킨다. 
예전 `cross-functional team` 개념을 그대로 사용한 것이다. 
사람들은 팀에 속한다는 느낌이 필요하다.

* 우리는 소속되어 있다.
* 우리는 이 안에 함께 있다.
* 우리는 서로의 작업, 성장, 배움을 돕는다. 

전체 팀을 구송하는 요소는 동적으로 변한다. 
어떤 기술이나 태도의 집합이 중요하다면, 그 기술을 지는 사람을 팀으로 데려온다. 
어떤 사람이 필요 없다면, 다른 곳에 가도 된다. 
프로젝트가 큰 경우 문제를 쪼개서 여러 팀으로 구성된 팀이 해결 방법을 찾는다면 XP를 대규모로 적용할 수 있다. 

### 7.3. 정보를 제공하는 작업 공간

작업 공간을 작업에 대한 것들로 채운다. 
프로젝트의 이해 관계자들이 프로젝트의 진행과 지금 문제, 앞으로 생길지 모르는 문제에 대해 더 많은 정보를 얻을 수 있어야 한다. 

* 벽에 스토리 카드를 붙인다.
* 진행되는 상황을 파악하기 위해서 크고 잘 보이는 차트를 만든다.

### 7.4. 활기찬 작업

생산적으로 일할 수 있는 정도의 시간만, 일의 활력을 유지할 수 있는 정도의 시간만 일한다. 
소프트웨어 개발은 통찰력 싸움이다. 
통찰력은 준비되고, 잘 쉬고, 긴장이 풀린 마음에서 생겨난다. 
작업자의 피곤함은 프로젝트의 가치를 떨어뜨리기 쉽다. 

### 7.5. 짝 프로그래밍

제품으로 출시할 모든 프로그램을 두 사람이 컴퓨터 한 대에 앉아 작성한다. 
두 사람이 편안하게 나란히 앉을 수 있도록 컴퓨터를 배치한다. 
짝 프로그래밍은 둘이서 동시에 프로그래밍을 하면서 프로그램을 더 낫게 만들려고 노력하는 두 사람 사이의 대화이다. 

* 서로 일에 집중하도록 도와준다.
* 시스템을 더 좋게 다듬기 위해 무엇을 할 수 있는지 브레인스토밍한다.
* 떠오른 생각을 명료하게 다듬어 준다.
* 한 사람이 막힐 때 주도권을 다른 사람에게 넘김으로써, 짜증을 덜 나게 해준다. 
* 팀에서 지키키로 한 실천방법을 서로 책임지고 지키도록 한다. 

짝 프로그래밍을 한다고 혼자 생각할 시간이 없어지는 것은 아니다. 
필요하다면 프로토타입을 만드는 등의 작업을 혼자 수행하고 곧바로 팀으로 돌아온다. 

#### 7.5.1. 짝 프로그래밍과 개인적 공간

가까운 거리 때문에 생기는 문제가 있다. 
편안함을 주는 신체적 공간의 크기는 사람마다 다르다. 
사람마다 다른 차이를 인식하지 못하면 불편해진다. 

### 7.6. 스토리 

고객이 볼 수 있는 기능을 단위로 해서 계획을 짜야한다. 
스토리와 요구사항 사이의 차이점은 일찍 추정하는 것이다. 
추정에서 사업과 기술적 시야가 상호 작용할 기회가 생긴다. 
이 기회를 통해 조기에 가치를 만들어낸다. 

스토리를 구체적인 정보에 입각하여 살펴본다. 
새로운 제약 조건들이 추가될수록 선택은 분명해진다. 
어떤 결정을 내리든 그 결정이 올바른 상황은 존재한다. 

### 7.7. 일주일별 주기

한번에 일주일 분량의 일을 계획한다. 
한 주를 시작하는 회의를 열고 다음과 같은 일을 한다. 

* 지금까지 진행된 상황을 검토한다.
* 지난 주의 실제 진행 정도가 예상 진행 정도를 달성했는지 검토한다. 
* 이번 주에 구현할 일주일 분의 스토리를 고객이 고르도록 한다. 
* 스토리를 여러 과업(task)으로 쪼갠다. 
* 팀 구성원들은 자기가 할 과업에 서명을 하고, 얼마나 걸릴지 추정한다. 

테스트가 겨우 통과하는 정도에서 구현을 끝내라. 
스토리를 완전하게 구현하지마라. 
우리의 목표는 일주일이 끝나갈 때 배치가 가능한 소프트웨어를 가지는 것이다. 

### 7.8. 분기별 주기

한 번에 한 분기 분량의 일을 계획한다. 
분기마다 한 번씩은 팀, 프로젝트, 프로젝트의 진행 정도, 더 높은 목표와 지금 프로젝트의 방향 일치 여부 등을 놓고 숙고해본다. 

* 병목, 특히 팀의 힘이 미치지 않는 외부에서 생기는 병목을 찾아본다. 
* 수선 작업을 시작한다.
* 이번 분기의 주제들을 계획한다.
* 그 주제들을 다룰 한 분기 분량의 스토리들을 고른다. 
* 프로젝트가 조직에서 차지하는 위치라는 큰 그림에 초점을 맞춘다. 

분기는 팀의 반성을 위한 좋은 시간 간격이다. 
모르는 사이에 팀을 갉아먹는 병목을 찾아낼 수 있다. 
장기 실험들을 제안하고 평가하는 데도 분기를 사용할 수 있다. 

### 7.9. 여유

어떤 계획이든, 일정에 뒤쳐질 경우 포기할 수 있는 비교적 덜 중요한 과업들을 포함시킨다. 
자기 공약을 지키는 것은 중요하다. 
잘 지킨 공약 몇 번은 관계를 재구축하는데 큰 도움이 된다. 

과도한 일정과 과소한 제공은 놀라운 낭비를 만든다.

* 결함 부담
* 엉망진창인 사기
* 적대적인 인관관계

약속을 지키는 것은 낭비를 제거한다. 
분명하고 솔직한 의사소통은 긴장을 완하하고 신뢰를 회복시킨다. 

### 7.10. 10분 빌드

10분 만에 자동으로 전체 시스템을 빌드하고 모든 테스트를 돌린다. 
빌드가 10분보다 오래 걸리면 그것을 실행하는 횟수가 현격하게 줄어든다. 
피드백을 받을 기회를 놓치게 된다. 

> 10분 만에 자동으로 전체 시스템을 빌드하고 모든 테스트를 돌린다. 

빌드 프로세스가 자동화되지 않았다면, 그것이 처음으로 개선할 지점이다. 
전체 시스템을 빌드하고 테스트하는 것이 중요하다. 
시스템의 일부분만 빌드하고 테스트하는 것은 실수를 저지를 위험을 만드는 것이다. 


### 7.11. 지속적 통합

변경한 것은 두세 시간 만에 통합하고 테스트한다. 
통합을 미룰수록 비용디 더 들고, 비용을 예측하기 힘들어진다. 

* 비동기식 방법
    * 변경한 것을 체크인하면 빌드 시스템이 변경이 있었음을 알아차리고 빌드와 테스트를 시작한다. 
    * 문제가 있으면 피드백을 받는다. 
* 동기식 방법
    * 프로그래밍 에피소드가 하나 끝날 때마다 통합을 수행한다. 
    * 테스트 스위트가 깨지는 것 없이 제대로 돌아갈 때까지 기다린다. 

동기식 방법은 자연스럽게 반성의 시간을 준다. 
컴파일이 끝나고 테스트가 돌아가는 것을 기다리면서 짝과 더 잘할 수 있는 방법에 대해 이야기한다. 
통합과 빌드의 결과물은 완제품이다. 
웹 사이트를 배치하는 것이라면, 정말 웹 사이트를 배치한다. 
언젠가 일어날 시스템의 첫 번째 실전 배치가 별일 아닌 것으로 느껴질 정도까지, 지속적인 통합은 완제품을 내놓아야 한다. 

### 7.12. 테스트 우선 프로그래밍

일단 실패하는 자동화된 테스트를 먼저 작성한다. 

* 슬금슬금 늘어나는 범위
    * 프로그래밍할 때 작성하는 '혹시 모르니까' 코드들을 줄인다.(최소한만 작성한다.)
    * 테스트를 통해 이 프로그램이 무엇을 해야 하는지 명시적이고 객관적으로 밝혀둔다. 
    * 코딩의 초점을 잃지 않는다. 
* 결합도와 응집성
    * 테스트를 작성하기 쉽지 않다면 테스트가 아니라 설계에 문제가 있다는 신호이다. 
    * 결합도가 낮고 응집성이 좋은 코드는 테스트하기 쉽다. 
* 신뢰
    * 작동하지 않는 코드를 작성한 사람은 신뢰하기 힘들다. 
    * 작동하는 깨끗한 코드를 작성하고 자동화 된 테스트로 의도를 드러내라.
* 리듬
    * 다음에 무슨 일을 해야할지 더욱 명확해진다.
    * 다음 할 일은 다른 테스트를 작성하거나 통과되지 않는 테스트를 통과하도록 만드는 일이다. 

### 7.13. 점진적 설계

시스템의 설계에 매일 투자한다. 
어떤 설계가 가능한 한도에서 최선의 설계인지 잘 이해해라. 
현재 설계가 우리가 이해한 최선의 설계와 일치하도록 점진적으로, 지속적으로 작업한다. 
중요한 결정은 초기에 내리고, 규모가 작은 결정들은 나중까지 미루는 것이 경제적인 설계 전략이다. 

매일 설계에 주의를 기울이지 않는다면 변경 비용은 커지기 마련이다. 
그 결과로 설계가 나쁘고, 깨지기 쉽고, 변경하기도 힘든 시스템이 나온다. 
XP 팀은 설계 투자를 단기에 최소하하는 것이 아니라, 시스템이 지금까지 필요한 부분에 대해서만 설계 투자를 유지해야 한다. 
설계를 언제하는지가 문제이다. 
설계를 사용하는 시점과 가까운 때에 설계하는게 더욱 효율적이다. 

설계를 개선할 부분을 찾는 방법은 다음과 같다.

* 중복을 제거한다.
* 두 부분에 동일한 논리가 있다면, 한 부분에만 있게 만드는 방법을 알아내기 위해 설계를 다시 해본다. 
* 리팩토링은 변경 작업에서 되풀이해서 나타나는 패턴을 정리해 놓은 설계 규율이다. 